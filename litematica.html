<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Gemini Multi-Parser (Schem & Litematic)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nbt@0.8.1/nbt.js"></script>
    <style>
        :root { --accent: #00ffcc; --bg: #0f172a; --panel: #1e293b; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #f8fafc; margin: 0; display: flex; flex-direction: column; height: 100vh; }
        header { background: #020617; padding: 1rem; border-bottom: 2px solid var(--accent); text-align: center; }
        .main-layout { display: grid; grid-template-columns: 350px 1fr; gap: 15px; padding: 15px; flex: 1; overflow: hidden; }
        .sidebar, .viewer { background: var(--panel); border-radius: 12px; padding: 20px; overflow-y: auto; }
        #drop-zone { border: 2px dashed #475569; border-radius: 8px; padding: 30px; text-align: center; cursor: pointer; background: #0f172a; margin-bottom: 15px; transition: 0.2s; }
        #drop-zone:hover { border-color: var(--accent); }
        .grid { display: grid; gap: 1px; background: #334155; margin: 0 auto; }
        .cell { width: 22px; height: 22px; background: #0f172a; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: help; }
        .controls { background: #020617; padding: 15px; border-radius: 8px; display: flex; align-items: center; gap: 15px; margin-bottom: 15px; }
        input[type=range] { flex: 1; accent-color: var(--accent); }
        table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
        th { text-align: left; color: var(--accent); border-bottom: 1px solid #475569; }
        td { padding: 6px 0; border-bottom: 1px solid #334155; }
        .block-tag { color: #facc15; font-weight: bold; }
        .info-badge { background: #334155; padding: 5px 10px; border-radius: 4px; font-size: 0.8em; margin-bottom: 10px; display: inline-block; }
    </style>
</head>
<body>

<header><h1>MINECRAFT BLUEPRINT EXPLAINER ðŸ’Ž</h1></header>

<div class="main-layout">
    <aside class="sidebar">
        <div id="drop-zone">ðŸ“‚ Charger .schematic ou .litematic</div>
        <div id="file-type" class="info-badge">En attente...</div>
        <div id="dim-info"></div>
        <h3>MatÃ©riaux</h3>
        <table id="mat-table">
            <thead><tr><th>Bloc</th><th>QuantitÃ©</th></tr></thead>
            <tbody></tbody>
        </table>
    </aside>

    <main class="viewer">
        <div class="controls">
            <span>COUCHE (Y): <b id="y-display" style="color:var(--accent)">0</b></span>
            <input type="range" id="y-range" value="0" min="0">
        </div>
        <div id="grid-container" style="overflow: auto; display: flex; justify-content: center;">
            <div id="grid" class="grid"></div>
        </div>
    </main>
</div>

<script>
    let schem = { w:0, h:0, l:0, blocks:[], palette:[] };

    document.getElementById('drop-zone').onclick = () => {
        const i = document.createElement('input'); i.type='file';
        i.onchange = e => handleFile(e.target.files[0]); i.click();
    };

    async function handleFile(file) {
        if (!file) return;
        document.getElementById('file-type').innerText = "Chargement...";
        const buffer = await file.arrayBuffer();
        try {
            const decompressed = pako.ungzip(new Uint8Array(buffer));
            nbt.parse(decompressed, (err, data) => {
                if (err) throw err;
                const root = data.value;
                if (root.Regions) {
                    parseLitematic(root);
                } else {
                    parseSchematic(root);
                }
                initUI(file.name);
            });
        } catch(e) { 
            console.error(e);
            alert("Erreur critique : " + e.message); 
        }
    }

    function parseSchematic(v) {
        document.getElementById('file-type').innerText = "Format: .SCHEMATIC";
        let palette = {};
        if (v.Palette) {
            Object.keys(v.Palette.value).forEach(name => palette[v.Palette.value[name].value] = name);
        } else {
            palette = { 0:"air", 1:"stone", 2:"grass", 3:"dirt", 4:"cobblestone" };
        }
        schem = {
            w: v.Width.value, h: v.Height.value, l: v.Length.value,
            blocks: Array.from(v.BlockData ? v.BlockData.value : v.Blocks.value),
            palette: palette
        };
    }

    function parseLitematic(v) {
    document.getElementById('file-type').innerText = "Format: .LITEMATIC";
    
    if (!v.Regions || !v.Regions.value) throw new Error("Aucune rÃ©gion trouvÃ©e");
    const regionName = Object.keys(v.Regions.value)[0];
    const region = v.Regions.value[regionName].value;
    
    const dims = region.Size.value;
    const w = Math.abs(dims.x.value);
    const h = Math.abs(dims.y.value);
    const l = Math.abs(dims.z.value);

    // Extraction palette ultra-safe
    const paletteRaw = region.BlockStatePalette.value;
    const items = Array.isArray(paletteRaw) ? paletteRaw : Object.values(paletteRaw);
    const palette = items.map(item => {
        if (item.Name && item.Name.value) return item.Name.value.replace("minecraft:", "");
        return "air";
    });
    
    // Si pas de blocs (ex: schÃ©ma vide)
    if (!region.BlockStates || !region.BlockStates.value) {
        schem = { w, h, l, blocks: new Int32Array(w * h * l).fill(0), palette };
        return;
    }

    const blockStates = region.BlockStates.value; 
    const bitsPerBlock = Math.max(2, Math.ceil(Math.log2(palette.length)));
    
    let extractedBlocks = new Int32Array(w * h * l);
    
    // Algorithme de dÃ©compression manuel sans passer par BigInt direct
    // pour Ã©viter l'erreur de syntaxe
    for (let i = 0; i < w * h * l; i++) {
        const startBit = i * bitsPerBlock;
        const index = Math.floor(startBit / 64);
        const bitOffset = startBit % 64;
        
        let currentLong = BigInt(blockStates[index].toString());
        let val;

        if (bitOffset + bitsPerBlock <= 64) {
            val = (currentLong >> BigInt(bitOffset)) & ((1n << BigInt(bitsPerBlock)) - 1n);
        } else {
            // Le bloc chevauche deux Longs
            let nextLong = BigInt(blockStates[index + 1].toString());
            let bitsFromFirst = 64 - bitOffset;
            let low = (currentLong >> BigInt(bitOffset));
            let high = (nextLong & ((1n << BigInt(bitsPerBlock - bitsFromFirst)) - 1n));
            val = low | (high << BigInt(bitsFromFirst));
            val &= (1n << BigInt(bitsPerBlock)) - 1n;
        }
        
        extractedBlocks[i] = Number(val);
    }

    schem = { w, h, l, blocks: extractedBlocks, palette: palette };
}

    function initUI(name) {
        const s = document.getElementById('y-range');
        s.max = schem.h - 1; s.value = 0;
        document.getElementById('dim-info').innerText = `Dimensions: ${schem.w}x${schem.h}x${schem.l}`;
        updateMaterials();
        render(0);
        s.oninput = (e) => {
            document.getElementById('y-display').innerText = e.target.value;
            render(parseInt(e.target.value));
        };
    }

    function updateMaterials() {
    const counts = {};
    for(let id of schem.blocks) { if(id !== 0) counts[id] = (counts[id] || 0) + 1; }
    
    document.querySelector('#mat-table tbody').innerHTML = Object.entries(counts)
        .sort((a,b) => b[1] - a[1])
        .map(([id, n]) => {
            const name = schem.palette[id] || "Inconnu";
            return `
                <tr onclick="this.style.opacity = this.style.opacity === '0.3' ? '1' : '0.3'" style="cursor:pointer">
                    <td class="block-tag">${name}</td>
                    <td>x${n}</td>
                    <td><input type="checkbox"></td>
                </tr>`;
        }).join('');
}

    function render(y) {
        const g = document.getElementById('grid');
        g.innerHTML = '';
        g.style.gridTemplateColumns = `repeat(${schem.w}, 22px)`;
        
        // L'ordre Litematic est souvent Y -> Z -> X
        const layerSize = schem.w * schem.l;
        const offset = y * layerSize;

        for (let i = 0; i < layerSize; i++) {
            const id = schem.blocks[offset + i];
            const cell = document.createElement('div');
            cell.className = 'cell';
            if(id > 0) {
                const name = Array.isArray(schem.palette) ? schem.palette[id] : schem.palette[id];
                cell.style.background = `hsl(${(id * 137) % 360}, 50%, 45%)`;
                cell.title = name;
                cell.innerText = name ? name.substring(10, 12).toUpperCase() : "";
            } else {
                cell.style.opacity = "0.1";
            }
            g.appendChild(cell);
        }
    }
</script>
</body>
</html>
